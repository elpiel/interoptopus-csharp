// Automatically generated by Interoptopus.

#pragma warning disable 0105
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
#if UNITY_2018_1_OR_NEWER
using Unity.Collections.LowLevel.Unsafe;
using Unity.Collections;
#endif
using Core.CSharp.Protobuf;
#pragma warning restore 0105

namespace Core.CSharp.Protobuf
{
    public static partial class CoreBindings
    {
        public const string NativeLib = "basic_csharp";

        static CoreBindings()
        {
        }


        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "api_guard")]
        public static extern Optionu64 api_guard();

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "storage_destroy")]
        public static extern FFIError storage_destroy(ref IntPtr context);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        public static void storage_destroy_checked(ref IntPtr context)
        {
            var rval = storage_destroy(ref context);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "storage_new")]
        public static extern FFIError storage_new(ref IntPtr context, GetStorageCallback get_callback, SetStorageCallback set_callback);

        public static void storage_new_checked(ref IntPtr context, GetStorageCallback get_callback, SetStorageCallback set_callback)
        {
            var rval = storage_new(ref context, get_callback, set_callback);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "storage_new")]
        public static extern FFIError storage_new(ref IntPtr context, IntPtr get_callback, IntPtr set_callback);


        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "storage_ascii_destroy")]
        public static extern FFIError storage_ascii_destroy(ref IntPtr context);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        public static void storage_ascii_destroy_checked(ref IntPtr context)
        {
            var rval = storage_ascii_destroy(ref context);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "storage_ascii_new")]
        public static extern FFIError storage_ascii_new(ref IntPtr context, GetStorageCallbackAscii get_callback, SetStorageCallbackAscii set_callback);

        public static void storage_ascii_new_checked(ref IntPtr context, GetStorageCallbackAscii get_callback, SetStorageCallbackAscii set_callback)
        {
            var rval = storage_ascii_new(ref context, get_callback, set_callback);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "storage_ascii_new")]
        public static extern FFIError storage_ascii_new(ref IntPtr context, IntPtr get_callback, IntPtr set_callback);


        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "storage_ascii_ffi_set")]
        public static extern FFIError storage_ascii_ffi_set(IntPtr context, string key, string value);

        public static void storage_ascii_ffi_set_checked(IntPtr context, string key, string value)
        {
            var rval = storage_ascii_ffi_set(context, key, value);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        /// if key is empty (`null` in C#) in storage we return `None` and json will be `null`` as well
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "storage_ascii_ffi_get")]
        public static extern FFIError storage_ascii_ffi_get(IntPtr context, string key, SliceMutu8 result, out ulong result_written);

        /// if key is empty (`null` in C#) in storage we return `None` and json will be `null`` as well
        public static void storage_ascii_ffi_get(IntPtr context, string key, byte[] result, out ulong result_written)
        {
            unsafe
            {
                fixed (void* ptr_result = result)
                {
                    var result_slice = new SliceMutu8(new IntPtr(ptr_result), (ulong) result.Length);
                    var rval = storage_ascii_ffi_get(context, key, result_slice, out result_written);;
                    if (rval != FFIError.Ok)
                    {
                        throw new InteropException<FFIError>(rval);
                    }
                }
            }
        }

        /// if key is empty (`null` in C#) in storage we return `None` and json will be `null`` as well
        #if UNITY_2018_1_OR_NEWER
        public static void storage_ascii_ffi_get(IntPtr context, string key, NativeArray<byte> result, out ulong result_written)
        {
            var result_slice = new SliceMutu8(result);
            var rval = storage_ascii_ffi_get(context, key, result_slice, out result_written);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }
        #endif

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "core_destroy")]
        public static extern FFIError core_destroy(ref IntPtr context);

        /// Destroys the given instance.
        ///
        /// # Safety
        ///
        /// The passed parameter MUST have been created with the corresponding init function;
        /// passing any other value results in undefined behavior.
        public static void core_destroy_checked(ref IntPtr context)
        {
            var rval = core_destroy(ref context);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        /// Takes a Storage instance to be used in the [`CSharpEnv`] impl
        ///
        /// On panic it should return an error because of the Service impl of [`interoptopus`].
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "core_initialize_native_with_debug_call")]
        public static extern FFIError core_initialize_native_with_debug_call(ref IntPtr context, DebugLogCallback debug_callback);

        /// Takes a Storage instance to be used in the [`CSharpEnv`] impl
        ///
        /// On panic it should return an error because of the Service impl of [`interoptopus`].
        public static void core_initialize_native_with_debug_call_checked(ref IntPtr context, DebugLogCallback debug_callback)
        {
            var rval = core_initialize_native_with_debug_call(ref context, debug_callback);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        /// Takes a Storage instance to be used in the [`CSharpEnv`] impl
        ///
        /// On panic it should return an error because of the Service impl of [`interoptopus`].
        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "core_initialize_native_with_debug_call")]
        public static extern FFIError core_initialize_native_with_debug_call(ref IntPtr context, IntPtr debug_callback);


        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "core_initialize_with_storage_with_set")]
        public static extern FFIError core_initialize_with_storage_with_set(ref IntPtr context, IntPtr storage);

        public static void core_initialize_with_storage_with_set_checked(ref IntPtr context, IntPtr storage)
        {
            var rval = core_initialize_with_storage_with_set(ref context, storage);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "core_initialize_with_storage_with_get")]
        public static extern FFIError core_initialize_with_storage_with_get(ref IntPtr context, IntPtr storage);

        public static void core_initialize_with_storage_with_get_checked(ref IntPtr context, IntPtr storage)
        {
            var rval = core_initialize_with_storage_with_get(ref context, storage);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "core_initialize_with_storage_without_set_get")]
        public static extern FFIError core_initialize_with_storage_without_set_get(ref IntPtr context, IntPtr storage, DebugLogCallback debug_callback);

        public static void core_initialize_with_storage_without_set_get_checked(ref IntPtr context, IntPtr storage, DebugLogCallback debug_callback)
        {
            var rval = core_initialize_with_storage_without_set_get(ref context, storage, debug_callback);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "core_initialize_with_storage_without_set_get")]
        public static extern FFIError core_initialize_with_storage_without_set_get(ref IntPtr context, IntPtr storage, IntPtr debug_callback);


        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "core_initialize_with_storage_ascii_with_set")]
        public static extern FFIError core_initialize_with_storage_ascii_with_set(ref IntPtr context, IntPtr storage);

        public static void core_initialize_with_storage_ascii_with_set_checked(ref IntPtr context, IntPtr storage)
        {
            var rval = core_initialize_with_storage_ascii_with_set(ref context, storage);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "core_initialize_with_storage_ascii_with_get")]
        public static extern FFIError core_initialize_with_storage_ascii_with_get(ref IntPtr context, IntPtr storage);

        public static void core_initialize_with_storage_ascii_with_get_checked(ref IntPtr context, IntPtr storage)
        {
            var rval = core_initialize_with_storage_ascii_with_get(ref context, storage);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "core_initialize_with_storage_ascii_without_set_get")]
        public static extern FFIError core_initialize_with_storage_ascii_without_set_get(ref IntPtr context, IntPtr storage, DebugLogCallback debug_callback);

        public static void core_initialize_with_storage_ascii_without_set_get_checked(ref IntPtr context, IntPtr storage, DebugLogCallback debug_callback)
        {
            var rval = core_initialize_with_storage_ascii_without_set_get(ref context, storage, debug_callback);;
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        [DllImport(NativeLib, CallingConvention = CallingConvention.Cdecl, EntryPoint = "core_initialize_with_storage_ascii_without_set_get")]
        public static extern FFIError core_initialize_with_storage_ascii_without_set_get(ref IntPtr context, IntPtr storage, IntPtr debug_callback);


    }

    public enum FFIError
    {
        Ok = 0,
        Null = 100,
        Panic = 200,
        Fail = 300,
    }

    ///A pointer to an array of data someone else owns which may be modified.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct SliceMutu8
    {
        ///Pointer to start of mutable data.
        #if UNITY_2018_1_OR_NEWER
        [NativeDisableUnsafePtrRestriction]
        #endif
        IntPtr data;
        ///Number of elements.
        ulong len;
    }

    public partial struct SliceMutu8 : IEnumerable<byte>
    {
        public SliceMutu8(GCHandle handle, ulong count)
        {
            this.data = handle.AddrOfPinnedObject();
            this.len = count;
        }
        public SliceMutu8(IntPtr handle, ulong count)
        {
            this.data = handle;
            this.len = count;
        }
        #if (NETSTANDARD2_1_OR_GREATER || NET5_0_OR_GREATER || NETCOREAPP2_1_OR_GREATER)
        public ReadOnlySpan<byte> ReadOnlySpan
        {
            get
            {
                unsafe
                {
                    return new ReadOnlySpan<byte>(this.data.ToPointer(), (int) this.len);
                }
            }
        }
        #endif
        #if UNITY_2018_1_OR_NEWER
        public SliceMutu8(NativeArray<byte> handle)
        {
            unsafe
            {
                this.data = new IntPtr(NativeArrayUnsafeUtility.GetUnsafeReadOnlyPtr(handle));
                this.len = (ulong) handle.Length;
            }
        }
        #endif
        #if (NETSTANDARD2_1_OR_GREATER || NET5_0_OR_GREATER || NETCOREAPP2_1_OR_GREATER)
        public Span<byte> Span
        {
            get
            {
                unsafe
                {
                    return new Span<byte>(this.data.ToPointer(), (int) this.len);
                }
            }
        }
        #endif
        public byte this[int i]
        {
            get
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                unsafe
                {
                    var d = (byte*) data.ToPointer();
                    return d[i];
                }
            }
            set
            {
                if (i >= Count) throw new IndexOutOfRangeException();
                unsafe
                {
                    var d = (byte*) data.ToPointer();
                    d[i] = value;
                }
            }
        }
        public byte[] Copied
        {
            get
            {
                var rval = new byte[len];
                for (var i = 0; i < (int) len; i++) {
                    rval[i] = this[i];
                }
                return rval;
            }
        }
        public int Count => (int) len;
        public IEnumerator<byte> GetEnumerator()
        {
            for (var i = 0; i < (int)len; ++i)
            {
                yield return this[i];
            }
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }


    ///Option type containing boolean flag and maybe valid data.
    [Serializable]
    [StructLayout(LayoutKind.Sequential)]
    public partial struct Optionu64
    {
        ///Element that is maybe valid.
        ulong t;
        ///Byte where `1` means element `t` is valid.
        byte is_some;
    }

    public partial struct Optionu64
    {
        public static Optionu64 FromNullable(ulong? nullable)
        {
            var result = new Optionu64();
            if (nullable.HasValue)
            {
                result.is_some = 1;
                result.t = nullable.Value;
            }

            return result;
        }

        public ulong? ToNullable()
        {
            return this.is_some == 1 ? this.t : (ulong?)null;
        }
    }


    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void DebugLogCallback(string debug_log);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate IntPtr GetStorageCallback(ref sbyte key);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate IntPtr GetStorageCallbackAscii(string key);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void SetStorageCallback(ref sbyte key, ref sbyte value);

    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    public delegate void SetStorageCallbackAscii(string key, string value);


    public partial class Storage : IDisposable
    {
        private IntPtr _context;

        private Storage() {}

        public static Storage New(GetStorageCallback get_callback, SetStorageCallback set_callback)
        {
            var self = new Storage();
            var rval = CoreBindings.storage_new(ref self._context, get_callback, set_callback);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = CoreBindings.storage_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public IntPtr Context => _context;
    }


    public partial class StorageAscii : IDisposable
    {
        private IntPtr _context;

        private StorageAscii() {}

        public static StorageAscii New(GetStorageCallbackAscii get_callback, SetStorageCallbackAscii set_callback)
        {
            var self = new StorageAscii();
            var rval = CoreBindings.storage_ascii_new(ref self._context, get_callback, set_callback);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = CoreBindings.storage_ascii_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public void FfiSet(string key, string value)
        {
            var rval = CoreBindings.storage_ascii_ffi_set(_context, key, value);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        /// if key is empty (`null` in C#) in storage we return `None` and json will be `null`` as well
        public void FfiGet(string key, SliceMutu8 result, out ulong result_written)
        {
            var rval = CoreBindings.storage_ascii_ffi_get(_context, key, result, out result_written);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        /// if key is empty (`null` in C#) in storage we return `None` and json will be `null`` as well
        public void FfiGet(string key, byte[] result, out ulong result_written)
        {
            CoreBindings.storage_ascii_ffi_get(_context, key, result, out result_written);
        }

        #if UNITY_2018_1_OR_NEWER
        /// if key is empty (`null` in C#) in storage we return `None` and json will be `null`` as well
        public void FfiGet(string key, NativeArray<byte> result, out ulong result_written)
        {
            CoreBindings.storage_ascii_ffi_get(_context, key, result, out result_written);
        }
        #endif

        public IntPtr Context => _context;
    }


    public partial class CoreService : IDisposable
    {
        private IntPtr _context;

        private CoreService() {}

        /// Takes a Storage instance to be used in the [`CSharpEnv`] impl
        ///
        /// On panic it should return an error because of the Service impl of [`interoptopus`].
        public static CoreService InitializeNativeWithDebugCall(DebugLogCallback debug_callback)
        {
            var self = new CoreService();
            var rval = CoreBindings.core_initialize_native_with_debug_call(ref self._context, debug_callback);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static CoreService InitializeWithStorageWithSet(IntPtr storage)
        {
            var self = new CoreService();
            var rval = CoreBindings.core_initialize_with_storage_with_set(ref self._context, storage);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static CoreService InitializeWithStorageWithGet(IntPtr storage)
        {
            var self = new CoreService();
            var rval = CoreBindings.core_initialize_with_storage_with_get(ref self._context, storage);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static CoreService InitializeWithStorageWithoutSetGet(IntPtr storage, DebugLogCallback debug_callback)
        {
            var self = new CoreService();
            var rval = CoreBindings.core_initialize_with_storage_without_set_get(ref self._context, storage, debug_callback);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static CoreService InitializeWithStorageAsciiWithSet(IntPtr storage)
        {
            var self = new CoreService();
            var rval = CoreBindings.core_initialize_with_storage_ascii_with_set(ref self._context, storage);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static CoreService InitializeWithStorageAsciiWithGet(IntPtr storage)
        {
            var self = new CoreService();
            var rval = CoreBindings.core_initialize_with_storage_ascii_with_get(ref self._context, storage);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public static CoreService InitializeWithStorageAsciiWithoutSetGet(IntPtr storage, DebugLogCallback debug_callback)
        {
            var self = new CoreService();
            var rval = CoreBindings.core_initialize_with_storage_ascii_without_set_get(ref self._context, storage, debug_callback);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
            return self;
        }

        public void Dispose()
        {
            var rval = CoreBindings.core_destroy(ref _context);
            if (rval != FFIError.Ok)
            {
                throw new InteropException<FFIError>(rval);
            }
        }

        public IntPtr Context => _context;
    }



    public class InteropException<T> : Exception
    {
        public T Error { get; private set; }

        public InteropException(T error): base($"Something went wrong: {error}")
        {
            Error = error;
        }
    }

}
